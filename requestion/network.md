

> 1.输入url到展示经过了哪些步骤

* 浏览器会查看当前的url有没有dns缓存，没有回到系统查看是否有dns缓存，如果有缓存直接读取缓存，没有缓存进行dns查询
* 拿到目标服务器的ip后，进行三次握手通信，可能会到nginx服务器
* 在nginx服务器进行中间层转发，最终到达目标服务器，目标服务器、参数不同进行不同的处理，最终返回对应的资源
* 如果返的是html，浏览器会对html进行解析，解析成对应的渲染树
* 开始渲染前会将head中的资源加载进行，如果是css会生成对应的样式渲染树，遇到script脚本会根据脚本加载特性的不同进行不同的处理
* 如果没有带defer、async属性会加载完脚本后在进行渲染步骤，如果是async属性会边加载边进行渲染，


> 2.三次握手

三次握手的目的：保证客户端和服务端都具有，发送、接收数据的能力

三次握手指的是传输层的Tcp协议为保证数据传输有效性的的策略：

开始阶段：客户端状态为closed、服务端为listen（监听状态）

* 第一次握手：客户端向服务端发送SYN=1（建立联机），报文中指定一个序列号（seq num），表明想要建立连接的想法。此时客户端处于SYN_send状态
* 第二次握手：服务端在接受到客户端的SYN，将客户端的序列号+1作为ASK作为回应，并在报文中返回服务端的序列号，返回ASK、SYN（同步标识），作为响应。表明服务端已经准备好可以建立连接了，此时服务端处于SYN_RCVD状态，半连接队列，若在指定时间内没有收到客户端响应，会重新回应，到底指定最大时间会进行重连
* 第三次握手：客户端在收到服务端的ACK后，将服务端的ISN+1作为ASK回应，表明可以通信了，客户端此时处于established

服务端在收到客户端的ASK后，状态变为established，后续双方开始通信



> 3.四次挥手

双方都处于established状态

* 第一次挥手客户端发送FIN报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1-1状态
* 第二次握手服务端在接收到FIN之后，将客户端的序列号+1作为ACK报文，发送给客户端表明已经接收到客户端断开连接的请求了，此时服务端处于CLOASE_WAIT
* 第三次挥手服务端也准备好断开连接了，会发送FIN，并指定一个序列号在报文发送给客户端，此时服务端处于LAST_WAIT状态
* 第四次挥手，客户端在接收到服务端的FIN后，一样会发一个ACK报文作为回应，并且把服务端的序列号值+1作为ACK报文的序列值，此时客户端处于TIME_WAIT状态，需要过一整子确保服务端收到自己的ACK后，才会进入CLOSED状态。这里为什么是TIME_WAIT,因为服务端没有收到客户端的ACK，会过一段时间重发FIN报文给客户端，客户端收到ASK就知道之前的ASK报文丢失了，就会重新发送ACK给服务端了

服务端收到ACK后就关闭了

> 4.https与http

为什么会出现https，因为http都是以明文的方式进行传输的，容易被读取修改

https=http+ssl(secure scokets layer)，安全协议、是可以进行加密、身份认证的协议

SSL协议是位于http之下，TCP之上的协议

* HTTPS采用非对称加密，如何减少加解密时间
    * 对称加密：加密和解密采用同一个秘钥，加解密速度快
    * 非对称加密：分为公钥和秘钥，公钥加密私钥解密，私钥加密，公钥解密，加解密速度慢
* 解决加解密慢的问题，非对称加密和对称加密混合使用：
    * 服务端对将要是用什么加密算法和秘钥通过私钥加密，传输给客户端
    * 客户端使用公钥对加密的内容进行解密，得到对称加密算法和私钥
    * 后续通过对称加密算法进行加解密

* 如何保证公钥不被串改，服务端在发送公钥的时候可能被第三方拦截，返回给客户端自己的公钥

* SSL/TSL协议交互过程：
    * 客户端向服务端索要并验证公钥
    * 双方协商生成对话秘钥
    * 双方采用对话秘钥通信
* 详细的交互过程
    * 客户端生成一串随机数，稍后用于生成对话秘钥。向服务端发送支持的加密算法如：RSA、TSL协议版本
    * 服务端确定TSL协议的版本，如果客户端不支持协议关闭加密通信。生成一串随机数，稍后用于生成对话秘钥，确定使用的TSL版本，向客户端发送服务端证书
    * 客户端收到服务端的回应后，会验证服务端证书，如果服务端证书不是可信机构、证书过期或者证书上的域名与实际域名不一致、就会向访问者显示一个警告，确认是否继续通信。如果证书没问题，客户端会从证书中取出服务端的公钥，然后向服务端发送三条信息：一个随机数使用公钥加密，编码发送时改变：随后都用双方协商的加密方法和秘钥发送。如果服务端需要客户端提供证书，这时也会发送证书
    * 服务端最后的响应：编码改变通知，表示随后的信息都将用双方协定的加密方式进行通信握手阶段结束通知
    * 接下来，客户端和服务端进行加密通信，使用的就是完完全全的HTTP协议，只不过用“会话秘钥”加密内容
* 简介http交互过程：
    * 客户端向服务端发送https请求
    * 服务端返回CA证书，CA证书内包括公钥。客户端验证CA证书是否有效，域名、有效时间等信息是否合规
    * 客户端生成对称加密秘钥，通过公钥加密传输给服务端，服务端返回信息表示后续通过对称加密信息进行通信
    * 进行加密通信


> 5.http请求中的get和post请求方式的区别

* get支持传输的数据类型较少只能通过url上拼接参数传递，无法传输字节流，post请求，支持传输的数据类型多，包括json、form表单，二进制文件
* get请求在进行跨域请求时浏览器不会触发options请求，post在跨域请求时，会触发options请求
* get传输的数据类型取决于浏览器地址的长度，post传输的数据量比get更大
* get请求会主动被浏览器cache，像资源文件这一类都是通过get请求获取的。post请求不会被cache
* get请求在浏览器回退时对浏览器来说是无害的不会重新请求，post会重新触发请求
* get相对来说比post不安全，因为敏感信息暴露在url中

* get和post没有本质上的区别，两者都是http协议中的两种请求方式
* get也可以在body中添加数据，不过不建议这么做
* get请求只发送一个tcp数据包、而post请求会发送两个数据包，get请求直接发送head 和data、而post会先发送head，服务端返回100状态（继续）时，才会发送剩余的data。当然在不同环境下实现的也不同
* 在浏览器上的区别：
    * 在浏览器回退或刷新的时候get请求是无害的，
    * 由于在浏览器上对请求的url长度是限制的，并且get请求在web端时没法在body添加数据，但是post请求可以在body中添加请求数据，所以post请求传输的数据比get请求更多，而且数据类型更广
    * 浏览器中get只能通过url上增加参数



> 6.常见的http状态

* 100（继续）
* 200（服务端成功响应）
* 301（永久重定向）包括location、302（临时重定向）、304（没有修改，从缓存读取）
* 400（参数错误、语义错误）、401（无权访问）、403（请求被拒绝了）、404找不到资源了、405（请求方式被拒绝了）
* 500（服务端出现未预料的错误）、503（服务端无法处理当前请求）、504（服务端超时了）


> 7.TCP和UDP的区别

* TCP协议是面向连接的协议，为保证数据可靠性，它有三次握手、四次挥手的策略。只能一对一通信
* UDP协议不是面向连接的，接收端和发送端不建立连接，发送方需要发送数据时，会直接向接收方发送数据，传输速度和时效很高，但不能保证数据是否正确传输，支持一对一或一对多通信

> 8.跨域

* 什么是跨域，什么时候回出现跨域需求：
    * 跨域是出于浏览器的同源策略限制，它限制了一个源的文档或脚本如何与另一个文档资源交互
    * 什么时候回出现跨域：协议、端口、主机不同时会出现跨域
    * 不同职责的服务放在不同的工程中，不同的工程会对应不同的域名，因此就会出现跨域问题
* 如何解决跨域：
    * jsonp的形式，因为浏览器允许跨域资源嵌入，像script、img标签。通过动态插入script标签来获取数据的方式
    * CORS是一种新的官方方案，使服务器支持跨域请求
        * 在服务器返回头中携带Access-Control-Allow-Origin: *
        * Access-Control-Allow-Methods: get、post、options
        * 表明支持跨域的域名，如果当前页面域名包含在支持的域名中，浏览器就不会拦截
        * CORS请求分为简单请求和非简单请求：
            * 简单请求：GET、HEAD、POST（content-type:text/plain、multipart/form-data、application/x-www-form-urlencoded），且没有人为设置首部字段集合之外的其他首部字段
            * 非简单请求，人为设置首部字段集合之外的其他首部字段
                * content-type不属于（content-type:text/plain、multipart/form-data、application/x-www-form-urlencoded）
            *  Access-Control-Allow-Credentials 为true，浏览器才会把响应结果传递给客户端程序
    * POSTmessage，跨窗口进行通信

